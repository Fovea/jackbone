{"name":"Jackbone","tagline":"JQuery Mobile meets Backbone","body":"Jackbone.js\r\n===========\r\n\r\nWhy use Jackbone?\r\n-----------------\r\n\r\nDeveloping Backbone + JQuery Mobile javascript applications is possible, but it's a pain. Jackbone is here to make it as easy as it should.\r\n\r\nSummary\r\n-------\r\n\r\nJackbone is a utility library that aims to structure the development of rich HTML5 applications using JQuery Mobile, by extending the Backbone framework. It heavily relies on Backbone, offering specialized classes for your **views** and **router**. Additionaly, it defines a **controller** interface, provide a **view manager** that handles life and death of the Views and Controllers of your application.\r\n\r\nLicence\r\n-------\r\n\r\n(c) 2013, Jean-Christophe Hoelt, Fovea.cc\r\n\r\nJackbone is available for use under the MIT software license.\r\n\r\nCode for this library was initially extracted from a work for FlightWatching's Checklist application.\r\n\r\nDocumentation\r\n=============\r\n\r\nMake sure you've read Backbone documentation first. This documentation will only cover the additions and differences between Jackbone and Backbone.\r\n\r\nMaybe you'd like to check-out some examples first?\r\n\r\n * Simple: [Hello World](https://github.com/Fovea/jackbone/blob/master/examples/helloworld/js/main.js)\r\n * More advanced: [Todo List](https://github.com/Fovea/jackbone/blob/master/examples/todolist/js/main.js)\r\n\r\n##Jackbone.View##\r\n\r\nJackbone views are basically Backbone views with extra features like:\r\n\r\n * necessary methods for the management of events binding for hidden but non-deleted views\r\n   * (when cached by Jackbone's ViewManager)\r\n * a child views hierarchy.\r\n * JQueryMobile specific callbacks.\r\n\r\n###subviews `object.subviews`\r\nArray of subviews for this view. Manipulate directly.\r\n\r\n###setOptions `object.setOptions(options)`\r\nChange options for this view and its subviews.\r\n\r\n###applyOptions `object.applyOptions()`\r\nCalled whenever options have been changed.\r\n*Overload* it to run your own custom code.\r\n\r\n###callSubviews `object.callSubviews(method, arguments...)`\r\nCall the given method for all subviews.\r\nPassing extra arguments is posible, they will be passed to subviews too.\r\n\r\n###bindEvents `object.bindEvents()`\r\nCalled whenever events binding is required.\r\n*Overload* it to bind your own callbacks to events.\r\n\r\n###unbindEvents `object.unbindEvents()`\r\nCalled whenever cleaning of events binding is required.\r\n*Overload* it to unbind your own callbacks to events.\r\n\r\n###refresh `object.refresh()`\r\nCalled whenever a refresh of you view is required.\r\nThe view already has been rendered, so it's better to only alter it if possible, instead of performing a full re-render.\r\n\r\n###onPageBeforeCreate `object.onPageBeforeCreate()`\r\nCalled before the page is enhanced by JQuery Mobile.\r\n*Overload* for your own use.\r\n\r\n###onPageCreate `object.onPageCreate()`\r\nCalled when the page is being enhanced by JQuery Mobile.\r\n*Overload* for your own use.\r\n\r\n###onPageBeforeShow `object.onPageBeforeShow()`\r\nCalled before the page starts being transitioned to.\r\n*Overload* for your own use.\r\n\r\n###onPageShow `object.onPageShow()`\r\nCalled when the page is done being transitioned to.\r\n*Overload* for your own use.\r\n\r\n###onPageBeforeHide `object.onPageBeforeHide()`\r\nCalled before the page starts being transitioned from.\r\n*Overload* for your own use.\r\n\r\n###onPageHide `object.onPageHide()`\r\nCalled when the page is done being transitioned from.\r\n*Overload* for your own use.\r\n\r\n###events `object.events`\r\n    events: {\r\n        'vclick': 'defaultEvent'\r\n    }\r\nBy default, views use a delegated event to check for clicks on elements that define a \"route\" attribute. **defaultEvent()** will open the page pointed by the route.\r\n\r\n###defaultEvent `object.defaultEvent(ev)`\r\nThis is the default event handler.\r\n\r\n###ignoreEvent `object.ignoreEvent(ev)`\r\nProvided for conveniance to views willing to ignore certain events.\r\n\r\n##Jackbone.Header and Jackbone.Footer\r\nLike `Jackbone.View`, but aimed to be used as page headers and footers.\r\n\r\n##Jackbone.Listview\r\nThe JQueryMobile Listview Helper\r\n\r\nHelps doing a clean refresh of a listview.\r\n\r\nUses a **ListviewUpdater** object:\r\n\r\n    ListviewUpdater: {\r\n        setLi: function ($li, model);\r\n        newLi: function (model);\r\n    }\r\n\r\n * **setLi** will adjust the content of jQuery li element according to the given JSON model.\r\n * **newLi** will create a new li element from given JSON model.\r\n\r\n###updateJSON `Listview.updateJSON($ul, collection, updater)`\r\nParameters:\r\n\r\n * **$ul**: a jQuery ul element\r\n * **collection**: JSON collection\r\n * **updater**: a `ListviewUpdater` (see above)\r\n\r\n###update `Listview.update($ul, collection, updater)`\r\nParameters:\r\n\r\n * **$ul**: a jQuery ul element\r\n * **collection**: Backbone collection\r\n * **updater**: a ListviewUpdater (see above)\r\n\r\n##Theming Options\r\n\r\n###Jackbone.DefaultHeader\r\nScreens may include a default header, which will be instanciated using the **Jackbone.DefaultHeader** View (a class extending **Jackbone.Header**).\r\n\r\nIt can be disabled globally by setting this to null or per screen by passing the **noHeader** option to **Router**'s **openView()** call.\r\n\r\n###Jackbone.DefaultFooter\r\nScreens may include a default footer too, instanciated using the **Jackbone.DefaultFooter** View (a class extending **Jackbone.Footer**).\r\n\r\nIt can be disabled globally by setting this to null or per screen by passing the **noFooter** option to **Router**'s **openView()** call.\r\n\r\n##Jackbone.Controller\r\n\r\nFor complex views that could be reused in different contexts it's better to create one (or many) controller.  Views will only handle input/output, whereas controllers will handle logic and interactions with models.\r\n\r\nBackbone doesn't provide a \"Controller\" interface, but Jackbone defines one. It's more than an interface, it's a also set of conventions that controllers have to follow.\r\n\r\nHere is what Controllers do:\r\n\r\n - Load models and collections.\r\n - Create the view, send it the appropriate 'options'.\r\n - Provide \"intelligence\" to the view as a set of callbacks.\r\n\r\n###Interaction with the view\r\nController should fill this.options in the initialize method.\r\n\r\nIn options, we add models and callbacks that the view will have to call. A very common callback is onRefresh(). onRefresh will be called by the view to refresh the models and collections, before it refreshes the interface.\r\n\r\n###Other things to know\r\nA Controller will be kept in cache by the ViewManager, for a few minutes after its View was hidden.\r\n\r\nLater on, controller's **destroy()** will be called by the garbage collector. This is where the Controller has to destroy structure it may have created.\r\n\r\nA nice way for a controller to monitor his view is by providing callbacks in the options.\r\n\r\n###Interaction with the view manager\r\n\r\nThe View Manager will instanciate controllers.\r\n\r\nIt will then look for this.view, an instanciated Jackbone.View\r\n\r\n###initialize `object.initialize(options)`\r\nInitialize the controller.  **this.view** has to be instanciated here.\r\n\r\n###destroy `object.destroy()`\r\nDestroy the controller, its views and models.\r\n\r\nOnly useful when some heavy resource have to be freed.\r\n\r\n###bindEvents `object.bindEvents()`\r\nCalled whenever events binding is required.\r\n**Overload** to bind your own callbacks to events.\r\n\r\n###unbindEvents `object.unbindEvents()`\r\nCalled whenever cleaning of events binding is required.\r\n**Overload** to unbind your own callbacks to events.\r\n\r\n##Jackbone.Router\r\n\r\nJackbone Router provide a clean way to navigate through pages by disabling JQueryMobile's own navigation engine and relying only on JQueryMobile's lower-level changePage method.\r\n\r\nUse **goto** method or set the **route** attribute to your HTML elements in order to navigate from view to view.\r\n\r\nOverride **routes** and call **openView** and **openDialog** in your own application's Router.\r\n\r\n###goto `object.goto(page, args)`\r\nNavigate to a new page.\r\n\r\n###getPageName `object.getPageName(page, args)`\r\nName of the page as referenced by the page-name attribute in the DOM.\r\n\r\n###getPageHash `object.getPageHash(page, args)`\r\nName of the page as referenced on the hash tag.\r\n\r\n###openView `object.openView(viewName, View, options, extra)`\r\nCreate the view if not already cached, then open it.\r\n\r\n**viewName + options** will identify the view in the cache, thus should be unique for each view.\r\n\r\n**extra** are additional options, to heavy to be used as a key in the cache.\r\n\r\n**View** has to be a **Jackbone.View** constructor.\r\n\r\n###openDialog `object.openDialog(viewName, View, options, extra)`\r\nSame as **openView**, but open the view as a dialog.\r\n\r\n###openViewController `object.openViewController(ctrlName, Controller, options, extra, role)`\r\nCreate view with a controller if not already cached, then open it. Behaviour is identical to **openView** except that **Controller** should be a **Jackbone.Controller** constructor instead of a **Jackbone.View**.\r\n\r\n###openDialogController `object.openDialogController(ctrlName, Controller, options, extra, role)`\r\nSame as **openViewController**, but open the view as a dialog.\r\n\r\n##Jackbone.History\r\nLike **Backbone.History**.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}